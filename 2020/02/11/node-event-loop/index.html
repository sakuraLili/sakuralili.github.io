<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Node.js 中的 Event Loop | 既然选择了远方，便只顾风雨兼程</title>
    <meta name="generator" content="VuePress 1.9.9">
    <link ref="icon" href="./public/favicon.icon">
    <meta name="description" content="注意区分：

 nodejs 的 event 是基于 libuv ，而浏览器的 event loop 则在 html5 的规范中明确定义
 libuv 已经对 event loop 作出了实现，而 html5 规范中只是定义了浏览器中` ev ...">
    
    <link rel="preload" href="/assets/css/0.styles.730f6d4f.css" as="style"><link rel="preload" href="/assets/js/app.c4cd884f.js" as="script"><link rel="preload" href="/assets/js/23.d4940eec.js" as="script"><link rel="preload" href="/assets/js/5.5d32c9ea.js" as="script"><link rel="preload" href="/assets/js/24.e000ab2c.js" as="script"><link rel="prefetch" href="/assets/js/10.a13898e2.js"><link rel="prefetch" href="/assets/js/11.ea480a48.js"><link rel="prefetch" href="/assets/js/12.0623054f.js"><link rel="prefetch" href="/assets/js/13.ef25626c.js"><link rel="prefetch" href="/assets/js/14.37d92c2e.js"><link rel="prefetch" href="/assets/js/15.186b7794.js"><link rel="prefetch" href="/assets/js/16.3a23dbe1.js"><link rel="prefetch" href="/assets/js/17.cf1e4c9d.js"><link rel="prefetch" href="/assets/js/18.733102b1.js"><link rel="prefetch" href="/assets/js/19.eb455b58.js"><link rel="prefetch" href="/assets/js/20.e1adbccc.js"><link rel="prefetch" href="/assets/js/21.70504574.js"><link rel="prefetch" href="/assets/js/22.a40e7218.js"><link rel="prefetch" href="/assets/js/25.2fe1472c.js"><link rel="prefetch" href="/assets/js/26.84502e94.js"><link rel="prefetch" href="/assets/js/27.c5d352fe.js"><link rel="prefetch" href="/assets/js/28.8e4ee861.js"><link rel="prefetch" href="/assets/js/29.fb15a9ed.js"><link rel="prefetch" href="/assets/js/3.2bd813b0.js"><link rel="prefetch" href="/assets/js/30.baf8f290.js"><link rel="prefetch" href="/assets/js/31.369fdd21.js"><link rel="prefetch" href="/assets/js/32.c0176c82.js"><link rel="prefetch" href="/assets/js/33.b3200294.js"><link rel="prefetch" href="/assets/js/34.08880f00.js"><link rel="prefetch" href="/assets/js/35.133a227c.js"><link rel="prefetch" href="/assets/js/36.293f2b2b.js"><link rel="prefetch" href="/assets/js/37.f92a5aa5.js"><link rel="prefetch" href="/assets/js/38.11242c63.js"><link rel="prefetch" href="/assets/js/39.1540f3d9.js"><link rel="prefetch" href="/assets/js/4.dde594c9.js"><link rel="prefetch" href="/assets/js/40.bc77545d.js"><link rel="prefetch" href="/assets/js/41.fe6b364e.js"><link rel="prefetch" href="/assets/js/42.6b17d3ae.js"><link rel="prefetch" href="/assets/js/43.d988bf22.js"><link rel="prefetch" href="/assets/js/44.9b709226.js"><link rel="prefetch" href="/assets/js/45.0797ebde.js"><link rel="prefetch" href="/assets/js/46.d41406d1.js"><link rel="prefetch" href="/assets/js/47.26d992a5.js"><link rel="prefetch" href="/assets/js/48.edf0660d.js"><link rel="prefetch" href="/assets/js/49.e1bd4b64.js"><link rel="prefetch" href="/assets/js/50.17997f4a.js"><link rel="prefetch" href="/assets/js/51.0731d59f.js"><link rel="prefetch" href="/assets/js/52.718863ae.js"><link rel="prefetch" href="/assets/js/53.4d2f7088.js"><link rel="prefetch" href="/assets/js/54.91ac93f6.js"><link rel="prefetch" href="/assets/js/55.3216e5c5.js"><link rel="prefetch" href="/assets/js/56.a2736731.js"><link rel="prefetch" href="/assets/js/57.93476b89.js"><link rel="prefetch" href="/assets/js/58.9984e9d6.js"><link rel="prefetch" href="/assets/js/59.27eeb159.js"><link rel="prefetch" href="/assets/js/6.e9162c19.js"><link rel="prefetch" href="/assets/js/60.83f3f7cd.js"><link rel="prefetch" href="/assets/js/61.322f6435.js"><link rel="prefetch" href="/assets/js/62.af66f292.js"><link rel="prefetch" href="/assets/js/63.777e9119.js"><link rel="prefetch" href="/assets/js/64.05118592.js"><link rel="prefetch" href="/assets/js/65.9ba14b43.js"><link rel="prefetch" href="/assets/js/66.62408b82.js"><link rel="prefetch" href="/assets/js/67.fa72ffa1.js"><link rel="prefetch" href="/assets/js/68.c16dfb41.js"><link rel="prefetch" href="/assets/js/7.f41c39e4.js"><link rel="prefetch" href="/assets/js/8.cd0ad175.js"><link rel="prefetch" href="/assets/js/9.f1977faa.js"><link rel="prefetch" href="/assets/js/vuejs-paginate.8fa4990d.js">
    <link rel="stylesheet" href="/assets/css/0.styles.730f6d4f.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div id="vuepress-theme-blog__global-layout"><section id="header-wrapper"><header id="header"><div class="header-wrapper"><div class="title"><a href="/" class="nav-link home-link">既然选择了远方，便只顾风雨兼程 </a></div> <div class="header-right-wrap"><ul class="nav"><li class="nav-item"><a href="/" class="nav-link">Blog</a></li><li class="nav-item"><a href="/tag/" class="nav-link">Tags</a></li><li class="nav-item"><a href="/2019/10/20/base-list/" class="nav-link">学习资源</a></li><li class="nav-item"><a href="/handbook/" class="nav-link">前端学习手册</a></li><li class="nav-item"><a href="/tag/Reading%20Notes/" class="nav-link">读书笔记</a></li></ul> <div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></div></header></section> <div id="mobile-header"><div class="mobile-header-bar"><div class="mobile-header-title"><a href="/" class="nav-link mobile-home-link">既然选择了远方，便只顾风雨兼程 </a> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg></div> <div class="mobile-menu-wrapper"><hr class="menu-divider"> <ul class="mobile-nav"><li class="mobile-nav-item"><a href="/" class="nav-link">Blog</a></li><li class="mobile-nav-item"><a href="/tag/" class="nav-link">Tags</a></li><li class="mobile-nav-item"><a href="/2019/10/20/base-list/" class="nav-link">学习资源</a></li><li class="mobile-nav-item"><a href="/handbook/" class="nav-link">前端学习手册</a></li><li class="mobile-nav-item"><a href="/tag/Reading%20Notes/" class="nav-link">读书笔记</a></li> <li class="mobile-nav-item"><!----></li></ul></div></div></div> <div class="content-wrapper"><div id="vuepress-theme-blog__post-layout"><article itemscope="itemscope" itemtype="https://schema.org/BlogPosting" class="vuepress-blog-theme-content"><header><h1 itemprop="name headline" class="post-title">
        Node.js 中的 Event Loop
      </h1> <div class="post-meta"><div itemprop="publisher author" itemtype="http://schema.org/Person" itemscope="itemscope" class="post-meta-author"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-navigation"><polygon points="3 11 22 2 13 21 11 13 3 11"></polygon></svg> <span itemprop="name">lili</span> <span itemprop="address">   in shenzhen</span></div> <div class="post-meta-date"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-clock"><circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline></svg> <time pubdate itemprop="datePublished" datetime="2020-02-11T00:00:00.000Z">
      Tue Feb 11 2020
    </time></div> <ul itemprop="keywords" class="post-meta-tags"><li class="post-tag" data-v-42ccfcd5><a href="/tag/JavaScript" data-v-42ccfcd5><span data-v-42ccfcd5>JavaScript</span></a></li><li class="post-tag" data-v-42ccfcd5><a href="/tag/Event Loop" data-v-42ccfcd5><span data-v-42ccfcd5>Event Loop</span></a></li><li class="post-tag" data-v-42ccfcd5><a href="/tag/Node.js" data-v-42ccfcd5><span data-v-42ccfcd5>Node.js</span></a></li></ul></div></header> <div itemprop="articleBody" class="content__default"><p>注意区分：</p> <ul><li><code>nodejs</code>的<code>event</code>是基于<code>libuv</code>，而浏览器的<code>event loop</code>则在<a href="https://www.w3.org/TR/html5/webappapis.html#event-loops" target="_blank" rel="noopener noreferrer"><code>html5</code>的规范<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>中明确定义</li> <li><code>libuv</code>已经对<code>event loop</code>作出了实现，而<code>html5</code>规范中只是定义了浏览器中<code>event loop</code>的模型，具体实现留给了浏览器厂商。</li></ul> <h2 id="nodejs中的event-loop"><a href="#nodejs中的event-loop" class="header-anchor">#</a> <code>NodeJS</code>中的<code>event loop</code></h2> <p>关于<code>nodejs</code>中的<code>event loop</code>有两个地方可以参考，一个是<code>nodejs</code><a href="https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/" target="_blank" rel="noopener noreferrer">官方的文档<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>；另一个是<code>libuv</code>的<a href="http://docs.libuv.org/en/v1.x/design.html" target="_blank" rel="noopener noreferrer">官方的文档<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>，前者已经对<code>nodejs</code>有一个比较完整的描述，而后者则有更多细节的描述。</p> <p>看图：</p> <p><img src="/assets/img/01.46ad5821.png" alt="image from dependency"></p> <ul><li>首先我们能看到我们的<code>js</code>代码（<code>APPLICATION</code>）会先进入<code>v8</code>引擎,<code>v8</code>引擎中主要是一些<code>setTimeout</code>之类的方法。</li> <li>其次如果我们的代码中执行了<code>nodeApi</code>，比如<code>require('fs').read()</code>，<code>node</code>就会交给<code>libuv</code>库处理，这个<code>libuv</code>库是别人写的，他就是<code>node</code>的事件环。</li> <li><code>libuv</code>库是通过单线程异步的方式来处理事件，我们可以看到<code>work threads</code>是个多线程的队列，通过外面<code>event loop</code>阻塞的方式来进行异步调用。</li> <li>等到<code>work threads</code>队列中有执行完成的事件，就会通过<code>EXECUTE CALLBACK</code>回调给<code>EVENT QUEUE</code>队列，把它放入队列中。</li> <li>最后通过事件驱动的方式，取出<code>EVENT QUEUE</code>队列的事件，交给我们的应用</li></ul> <h2 id="一、nodejs的event-loop阶段"><a href="#一、nodejs的event-loop阶段" class="header-anchor">#</a> 一、<code>nodeJS</code>的<code>Event Loop</code>阶段</h2> <p>当<code>Node.js</code>启动时，会做这几件事：</p> <ol><li>初始化<code>event loop</code></li> <li>开始执行脚本（或者进入<code>REPL</code>）。这些脚本有可能会调用一些异步<code>API</code>、设定定时器或者调用<code>process.nextTick()</code></li> <li>开始处理<code>event loop</code></li></ol> <p>处理<code>event loop</code>的过程如图所示：</p> <p><img src="/assets/img/02.386cd331.png" alt="image from dependency"></p> <p>图中每个方框都是<code>event loop</code>中的一个阶段。</p> <p>每个阶段都有一个先入先出队列，这个队列存有要执行的回调函数地址。不过每个阶段都有其特有的使命。一般来说，当<code>event loop</code> 达到某个阶段时，会在这个阶段进行一些特殊的操作，然后执行这个阶段的队列里的所有回调。 下列两种情况之一会停止止执行这些回调：</p> <ul><li>队列的操作全被执行完了</li> <li>执行的回调数目到达指定的最大值 然后，<code>event loop</code> 进入下一个阶段，然后再下一个阶段</li></ul> <p>一方面，上面这些操作都有可能添加计时器；另一方面，操作系统会向<code>poll</code>队列中添加新的事件，当<code>poll</code> 队列中的事件被处理时可能会有新的<code>poll</code>事件进入<code>poll</code> 队列。结果，耗时较长的回调函数可以让<code>event loop</code>在<code>poll</code> 阶段停留很久，久到错过了计时器的触发时机。</p> <p>注意，<code>Windows</code>的实现和<code>Unix/Linux</code> 的实现稍有不同，不过对本文内容影响不大。本文囊括了<code>event loop</code>最重要的部分，不同平台可能有七个或八个阶段，但是上面的几个阶段是我们真正关心的阶段，而且是<code>Node.js</code> 真正用到的阶段。</p> <h2 id="二、各阶段概览"><a href="#二、各阶段概览" class="header-anchor">#</a> 二、各阶段概览</h2> <ul><li><code>timers</code>阶段：这个阶段执行<code>setTimeout</code>和 <code>setInterval</code>的回调函数。</li> <li><code>I/O callbacks</code>阶段：不在<code>timers</code>阶段、<code>close callbacks</code>阶段和<code>check</code> 阶段这三个阶段执行的回调，都由此阶段负责，这几乎包含了所有回调函数。</li> <li><code>idle</code>, <code>prepare</code>阶段：<code>event loop</code>内部使用的阶段。</li> <li><code>poll</code>阶段：获取新的<code>I/O</code>事件。在某些场景下<code>Node.js</code> 会阻塞在这个阶段。</li> <li><code>check</code>阶段：执行<code>setImmediate()</code>的回调函数。</li> <li><code>close callbacks</code>阶段：执行关闭事件的回调函数，如<code>socket.on('close', fn)</code>里的<code>fn</code>。</li></ul> <p>一个<code>Node.js</code>程序结束时，<code>Node.js</code>会检查<code>event loop</code> 是否在等待异步<code>I/O</code> 操作结束，是否在等待计时器触发，如果没有，就会关掉<code>event loop</code>。</p> <h2 id="三、各阶段详解"><a href="#三、各阶段详解" class="header-anchor">#</a> 三、各阶段详解</h2> <h3 id="_3-1-timers阶段"><a href="#_3-1-timers阶段" class="header-anchor">#</a> 3.1 <code>timers</code>阶段</h3> <p>计时器指定多久以后可以执行某个回调函数。当指定的时间达到后，计时器的回调函数会尽早被执行。如果操作系统很忙，或者<code>Node.js</code>正在执行一个耗时的函数，那么计时器的回调函数就会被推迟执行。</p> <p>注意，从原理上来说，<code>poll</code> 阶段能控制计时器的回调函数什么时候被执行。</p> <p>举例来说，你设置了一个计时器在<code>100</code> 毫秒后执行，然后你的脚本用了<code>95</code>毫秒来异步读取了一个文件：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> fs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'fs'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">someAsyncOperation</span><span class="token punctuation">(</span><span class="token parameter">callback</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 假设读取这个文件一共花费 95 毫秒</span>
  fs<span class="token punctuation">.</span><span class="token function">readFile</span><span class="token punctuation">(</span><span class="token string">'/path/to/file'</span><span class="token punctuation">,</span> callback<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> timeoutScheduled <span class="token operator">=</span> Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> delay <span class="token operator">=</span> Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> timeoutScheduled<span class="token punctuation">;</span>

  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>delay<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">毫秒后执行了 setTimeout 的回调</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>


<span class="token comment">// 执行一个耗时 95 毫秒的异步操作</span>
<span class="token function">someAsyncOperation</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> startCallback <span class="token operator">=</span> Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// 执行一个耗时 10 毫秒的同步操作</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> startCallback <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 什么也不做</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre></div><p>当<code>event loop</code>进入<code>poll</code>阶段，发现<code>poll</code> 队列为空（因为文件还没读完），<code>event loop</code> 检查了一下最近的计时器，大概还有<code>100</code>毫秒时间，于是<code>event loop</code>决定这段时间就停在<code>poll</code>阶段。在<code>poll</code>阶段停了<code>95</code>毫秒之后，<code>fs.readFile</code>操作完成，一个耗时<code>10</code> 毫秒的回调函数被系统放入<code>poll</code>队列，于是<code>event loop</code> 执行了这个回调函数。执行完毕后，<code>poll</code>队列为空，于是<code>event loop</code>去看了一眼最近的计时器, <code>event loop</code>发现，已经超时<code>95 + 10 - 100 = 5</code>毫秒了，于是经由<code>check</code>阶段、<code>close callbacks</code>阶段绕回到<code>timers</code>阶段，执行<code>timers</code> 队列里的那个回调函数。这个例子中，<code>100</code> 毫秒的计时器实际上是在<code>105</code>毫秒后才执行的。</p> <p>注意：为了防止<code>poll</code>阶段占用了<code>event loop</code> 的所有时间，<code>libuv</code>（<code>Node.js</code>用来实现<code>event loop</code>和所有异步行为的<code>C</code>语言写成的库）对<code>poll</code> 阶段的最长停留时间做出了限制，具体时间因操作系统而异。</p> <h3 id="_3-2-i-o-callbacks阶段"><a href="#_3-2-i-o-callbacks阶段" class="header-anchor">#</a> 3.2 <code>I/O callbacks</code>阶段</h3> <p>这个阶段会执行一些系统操作的回调函数，比如<code>TCP</code> 报错，如果一个<code>TCP socket</code>开始连接时出现了<code>ECONNREFUSED</code> 错误，一些<code>*nix</code>系统就会（向 <code>Node.js</code>）通知这个错误。这个通知就会被放入<code>I/O callbacks</code>队列。</p> <h3 id="_3-3-poll阶段-轮询阶段"><a href="#_3-3-poll阶段-轮询阶段" class="header-anchor">#</a> 3.3 <code>poll</code>阶段（轮询阶段）</h3> <p><code>poll</code>阶段有两个功能：</p> <ol><li>如果发现计时器的时间到了，就绕回到<code>timers</code> 阶段执行计时器的回调。</li> <li>然后再执行<code>poll</code>队列里的回调。</li></ol> <p>当<code>event loop</code>进入<code>poll</code>阶段，如果发现没有计时器，就会：</p> <ol><li>如果<code>poll</code>队列不是空的，<code>event loop</code> 就会依次执行队列里的回调函数，直到队列被清空或者到达<code>poll</code> 阶段的时间上限。</li> <li>如果<code>poll</code>队列是空的，就会：</li></ol> <ul><li>如果有<code>setImmediate()</code>任务，<code>event loop</code>就结束<code>poll</code> 阶段去往<code>check</code>阶段。</li> <li>如果没有<code>setImmediate()</code>任务，<code>event loop</code> 就会等待新的回调函数进入<code>poll</code>队列，并立即执行它。</li></ul> <p>一旦<code>poll</code>队列为空，<code>event loop</code> 就会检查计时器有没有到期，如果有计时器到期了，<code>event loop</code> 就会回到<code>timers</code>阶段执行计时器的回调。</p> <h3 id="_3-4-check阶段"><a href="#_3-4-check阶段" class="header-anchor">#</a> 3.4 <code>check</code>阶段</h3> <p>这个阶段允许开发者在<code>poll</code>阶段结束后立即执行一些函数。如果 <code>poll</code>阶段空闲了，同时存在<code>setImmediate()</code>任务，<code>event loop</code>就会进入<code>check</code>阶段。</p> <p><code>setImmediate()</code> 实际上是一种特殊的计时器，有自己特有的阶段。它是通过<code>libuv</code> 里一个能将回调安排在<code>poll</code>阶段之后执行的<code>API</code>实现的。</p> <p>一般来说，当代码执行后，<code>event loop</code>最终会达到<code>poll</code> 阶段，等待新的连接、新的请求等。但是如果一个回调是由 <code>setImmediate()</code>发出的，同时<code>poll</code>阶段空闲下来了，<code>event loop</code>就会结束<code>poll</code>阶段进入<code>check</code>阶段，不再等待新的<code>poll</code>事件。</p> <h3 id="_3-5-close-callbacks阶段"><a href="#_3-5-close-callbacks阶段" class="header-anchor">#</a> 3.5 <code>close callbacks</code>阶段</h3> <p>如果一个<code>socket</code>或者<code>handle</code>被突然关闭（比如 <code>socket.destroy()</code>），那么就会有一个<code>close</code> 事件进入这个阶段。否则，这个<code>close</code>事件就会经过 <code>process.nextTick()</code>触发。</p> <h2 id="微任务和宏任务"><a href="#微任务和宏任务" class="header-anchor">#</a> 微任务和宏任务</h2> <p>每次执行栈的同步任务执行完毕，就会去任务队列中取出完成的异步任务，队列中又分为<code>microtasks queues</code>和宏任务队。等到把<code>microtasks queues</code>所有的<code>microtasks</code>都执行完毕,注意是所有的,他才会从宏任务队列中取事件。等到把队列中的事件取出一个，放入执行栈执行完成，就算一次循环结束，之后<code>event loop</code>继续循环，他会再去<code>microtasks queues</code>执行所有的任务，然后再从宏任务队列里面取一个，如此反复循环。</p> <ul><li>同步任务执行完</li> <li>去执行<code>microtasks</code>，把所有<code>microtasks queues</code>清空</li> <li>取出一个<code>macrotasks queues</code>的完成事件，在执行栈执行</li> <li>再去执行<code>microtasks</code></li> <li><code>...</code></li> <li><code>...</code></li> <li><code>...</code></li></ul> <h3 id="macrotasks与microtasks的区别"><a href="#macrotasks与microtasks的区别" class="header-anchor">#</a> <code>macrotasks</code>与<code>microtasks</code>的区别</h3> <ul><li><code>macrotasks</code>: <code>setTimeout</code>、<code>setInterval</code> 、<code>setImmediate</code>、 <code>I/O</code>、<code>UI</code>渲染</li> <li><code>microtasks</code>: <code>Promise</code>、 <code>process.nextTick</code>、<code>Object.observe</code>、 <code>MutationObserver</code>。</li></ul> <p>在<a href="https://promisesaplus.com/#notes" target="_blank" rel="noopener noreferrer"><code>Promise/A+</code>的规范<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>中，<code>Promise</code>的实现可以是微任务，也可以是宏任务，但是普遍的共识表示(至少<code>Chrome</code>是这么做的)，<code>Promise</code> 应该是属于微任务阵营的</p> <p>看图：</p> <p><img src="/assets/img/03.e69102a4.jpg" alt="image from dependency"></p> <p>绿色小块是<code>macrotask</code>（宏任务），<code>macrotask</code> 中间的粉红箭头是<code>microtask</code>（微任务）。</p> <p>举个例子：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'A'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> obj<span class="token operator">=</span><span class="token punctuation">{</span>
    <span class="token function-variable function">func</span><span class="token operator">:</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'B'</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">resolve</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'C'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
obj<span class="token punctuation">.</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'D'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'E'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><ol><li>首先<code>setTimeout A</code>被加入到事件队列中<code>==&gt;</code> 此时<code>macrotasks</code>中有<code>[‘A’]</code>；</li> <li><code>obj.func()</code>执行时，<code>setTimeout B</code> 被加入到事件队列中<code>==&gt;</code> 此时<code>macrotasks</code>中有<code>[‘A’，‘B’]</code>；</li> <li>接着<code>return</code>一个<code>Promise</code>对象，<code>Promise</code> 新建后立即执行 执行<code>console.log('C')</code>; 控制台首次打印<code>‘C’</code>;</li> <li>然后，<code>then</code>方法指定的回调函数，被加入到<code>microtasks</code>当前脚本所有同步任务执行完才会执行。 <code>==&gt;</code> 此时<code>microtasks</code>中有<code>[‘D’]</code>；</li> <li>然后继续执行当前脚本的同步任务，故控制台第二次输出<code>‘E’</code>；</li> <li>此时所有同步任务执行完毕，如上所述先检查<code>microtasks</code>其中所有任务，故控制台第三次输出<code>‘D’</code>；</li> <li>最后再执行<code>macrotask</code>的任务，并且按照入队列的时间顺序，控制台第四次输出<code>‘A’</code>，控制台第五次输出<code>‘B’</code>。</li></ol> <h2 id="四、setimmediate-vs-settimeout"><a href="#四、setimmediate-vs-settimeout" class="header-anchor">#</a> 四、<code>setImmediate() vs setTimeout()</code></h2> <p><code>setImmediate</code>和<code>setTimeout</code> 很相似，但是其回调函数的调用时机却不一样。</p> <p><code>setImmediate()</code>的作用是在当前<code>poll</code> 阶段结束后调用一个函数。 <code>setTimeout()</code> 的作用是在一段时间后调用一个函数。 这两者的回调的执行顺序取决于<code>setTimeout</code>和<code>setImmediate</code> 被调用时的环境。</p> <p>举例来说，如果在主模块中运行下面的脚本，那么两个回调的执行顺序是无法判断的：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'timeout'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">setImmediate</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'immediate'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>运行结果如下：</p> <div class="language-script extra-class"><pre class="language-text"><code>$ node timeout_vs_immediate.js
timeout
immediate

$ node timeout_vs_immediate.js
immediate
timeout
</code></pre></div><p><code>setTimeout/setInterval</code>的第二个参数取值范围是：<code>[1, 2^31 - 1]</code>，如果超过这个范围则会初始化为<code>1</code>，即<code>setTimeout(fn, 0) === setTimeout(fn, 1)</code>。我们知道<code>setTimeout</code>的回调函数在<code>timer</code>阶段执行，<code>setImmediate</code>的回调函数在 <code>check</code>阶段执行，<code>event loop</code>的开始会先检查<code>timer</code> 阶段，但是在开始之前到<code>timer</code> 阶段会消耗一定时间，所以就会出现两种情况：</p> <ol><li><code>timer</code>前的准备时间超过<code>1ms</code>，满足<code>loop-&gt;time &gt;= 1</code>，则执行<code>timer</code>阶段（<code>setTimeout</code>）的回调函数</li> <li><code>timer</code>前的准备时间小于<code>1ms</code>，则先执行<code>check</code> 阶段（<code>setImmediate</code>）的回调函数，下一次<code>event loop</code>执行 <code>timer</code>阶段（<code>setTimeout</code>）的回调函数</li></ol> <p>但是，如果把上面代码放到<code>I/O</code>操作的回调里，<code>setImmediate</code>的回调就总是优先于<code>setTimeout</code>的回调：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// timeout_vs_immediate.js</span>
<span class="token keyword">const</span> fs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'fs'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

fs<span class="token punctuation">.</span><span class="token function">readFile</span><span class="token punctuation">(</span>__filename<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'timeout'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">setImmediate</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'immediate'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre></div><p>运行结果如下：</p> <div class="language-script extra-class"><pre class="language-text"><code>$ node timeout_vs_immediate.js
immediate
timeout
</code></pre></div><p><code>fs.readFile</code>的回调函数执行完后：</p> <ol><li>注册<code>setTimeout</code>的回调函数到<code>timer</code>阶段</li> <li>注册<code>setImmediate</code>的回调函数到<code>check</code></li> <li><code>event loop</code>从<code>pool</code>阶段出来继续往下一个阶段执行，恰好是<code>check</code>阶段，所以<code>setImmediate</code>的回调函数先执行</li> <li>本次<code>event loop</code>结束后，进入下一次<code>event loop</code>，执行 <code>setTimeout</code>的回调函数</li></ol> <p>所以，在<code>I/O Callbacks</code>中注册的<code>setTimeout</code>和<code>setImmediate</code>，永远都是<code>setImmediate</code>先执行。</p> <h2 id="五、process-nexttick"><a href="#五、process-nexttick" class="header-anchor">#</a> 五、<code>process.nextTick()</code></h2> <p>在任何一个阶段调用<code>process.nextTick</code>(回调)，回调都会在当前阶段继续运行前被调用。这种行为有的时候会造成不好的结果，因为可以递归地调用<code>process.nextTick()</code>，这样<code>event loop</code> 就会一直停在当前阶段不走,无法进入<code>poll</code>阶段。</p> <p>比如如下代码：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'setInterval'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span>

process<span class="token punctuation">.</span><span class="token function">nextTick</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">tick</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  process<span class="token punctuation">.</span><span class="token function">nextTick</span><span class="token punctuation">(</span>tick<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>运行结果：<code>setInterval</code>永远不会打印出来。</p> <p><code>process.nextTick</code>会无限循环,使<code>event loop</code>停留在当前阶段，无法进入<code>timers</code>阶段。</p> <p>解决方法通常是用<code>setImmediate</code>替代<code>process.nextTick</code>，如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'setInterval'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span>

<span class="token function">setImmediate</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">immediate</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">setImmediate</span><span class="token punctuation">(</span>immediate<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p><code>setImmediate</code>内执行<code>setImmediate</code>会将<code>immediate</code>函数注册到下一次<code>event loop</code>的<code>check</code>阶段，而不是当前正在执行的<code>check</code>阶段，所以给了<code>event loop</code>上其他阶段执行的机会。</p> <h2 id="六、process-nexttick-vs-setimmediate"><a href="#六、process-nexttick-vs-setimmediate" class="header-anchor">#</a> 六、<code>process.nextTick() vs setImmediate()</code></h2> <p><code>process.nextTick()</code>的回调会在当前<code>event loop</code>阶段「立即」执行。 <code>setImmediate()</code>的回调会在后续的<code>event loop</code> 周期（<code>tick</code>）执行。</p> <p>推荐开发者在任何情况下都使用<code>setImmediate()</code>，因为它的兼容性更好，而且它更容易理解。</p> <h2 id="七、什么时候用process-nexttick"><a href="#七、什么时候用process-nexttick" class="header-anchor">#</a> 七、什么时候用<code>process.nextTick()</code></h2> <p>使用的理由有两个：</p> <ol><li>让开发者处理错误、清除无用的资源，或者在<code>event loop</code>当前阶段结束前尝试重新请求资源</li> <li>有时候有必要让一个回调在调用栈<code>unwind</code>之后，<code>event loop</code>进入下阶段之前执行</li></ol> <p>为了让代码更合理，我们可能会写这样的代码：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> server <span class="token operator">=</span> net<span class="token punctuation">.</span><span class="token function">createServer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
server<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'connection'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">conn</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

server<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">8080</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
server<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'listening'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>假设<code>listen()</code>在<code>event loop</code>一启动的时候就执行了，而<code>listening</code>事件的回调被放在了<code>setImmediate()</code>里，<code>listen</code> 动作是立即发生的，如果想要<code>event loop</code>执行<code>listening</code>回调，就必须先经过<code>poll</code>阶段，当时<code>poll</code> 阶段有可能会停留，以等待连接，这样一来就有可能出现<code>connect</code>事件的回调比<code>listening</code>事件的回调先执行。这显然不合理，所以我们需要用 <code>process.nextTick</code></p> <p>再举一个例子，一个类继承了<code>EventEmitter</code>，而且想在实例化的时候触发一个事件：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> EventEmitter <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'events'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> util <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'util'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">MyEmitter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">EventEmitter</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">emit</span><span class="token punctuation">(</span><span class="token string">'event'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
util<span class="token punctuation">.</span><span class="token function">inherits</span><span class="token punctuation">(</span>MyEmitter<span class="token punctuation">,</span> EventEmitter<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> myEmitter <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyEmitter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
myEmitter<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'event'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'an event occurred!'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre></div><p>不能直接在构造函数里执行<code>this.emit('event')</code>，因为这样的话后面的回调就永远无法执行。把<code>this.emit('event')</code>放在<code>process.nextTick()</code>里，后面的回调就可以执行，这才是我们预期的行为：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> EventEmitter <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'events'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> util <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'util'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">MyEmitter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">EventEmitter</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// use nextTick to emit the event once a handler is assigned</span>
  process<span class="token punctuation">.</span><span class="token function">nextTick</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">emit</span><span class="token punctuation">(</span><span class="token string">'event'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
util<span class="token punctuation">.</span><span class="token function">inherits</span><span class="token punctuation">(</span>MyEmitter<span class="token punctuation">,</span> EventEmitter<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> myEmitter <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyEmitter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
myEmitter<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'event'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'an event occurred!'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="参考文献"><a href="#参考文献" class="header-anchor">#</a> 参考文献：</h2> <p><a href="https://juejin.im/post/5ab7677f6fb9a028d56711d0" target="_blank" rel="noopener noreferrer">Event Loop、计时器、nextTick<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>原文： <a href="https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/" target="_blank" rel="noopener noreferrer">https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><a href="https://zhuanlan.zhihu.com/p/34182184" target="_blank" rel="noopener noreferrer">Event Loop 必知必会（六道题）<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><a href="https://juejin.im/post/5b35cdfa51882574c020d685" target="_blank" rel="noopener noreferrer">node基础面试事件环？微任务、宏任务？一篇带你飞<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><a href="https://juejin.im/post/5b73d7a6518825610072b42b" target="_blank" rel="noopener noreferrer">微任务、宏任务与Event-Loop<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></div> <footer><!----> <hr> <!----></footer></article> <div class="sticker vuepress-toc"><div class="vuepress-toc-item vuepress-toc-h2 active"><a href="#nodejs中的event-loop" title="NodeJS 中的 event loop">NodeJS 中的 event loop</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#一、nodejs的event-loop阶段" title="一、 nodeJS 的 Event Loop 阶段">一、 nodeJS 的 Event Loop 阶段</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#二、各阶段概览" title="二、各阶段概览">二、各阶段概览</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#三、各阶段详解" title="三、各阶段详解">三、各阶段详解</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_3-1-timers阶段" title="3.1  timers 阶段">3.1  timers 阶段</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_3-2-i-o-callbacks阶段" title="3.2  I/O callbacks 阶段">3.2  I/O callbacks 阶段</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_3-3-poll阶段-轮询阶段" title="3.3  poll 阶段（轮询阶段）">3.3  poll 阶段（轮询阶段）</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_3-4-check阶段" title="3.4  check 阶段">3.4  check 阶段</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_3-5-close-callbacks阶段" title="3.5  close callbacks 阶段">3.5  close callbacks 阶段</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#微任务和宏任务" title="微任务和宏任务">微任务和宏任务</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#macrotasks与microtasks的区别" title="macrotasks 与 microtasks 的区别">macrotasks 与 microtasks 的区别</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#四、setimmediate-vs-settimeout" title="四、 setImmediate() vs setTimeout()">四、 setImmediate() vs setTimeout()</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#五、process-nexttick" title="五、 process.nextTick()">五、 process.nextTick()</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#六、process-nexttick-vs-setimmediate" title="六、 process.nextTick() vs setImmediate()">六、 process.nextTick() vs setImmediate()</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#七、什么时候用process-nexttick" title="七、什么时候用 process.nextTick()">七、什么时候用 process.nextTick()</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#参考文献" title="参考文献：">参考文献：</a></div></div></div></div> <footer class="footer" data-v-3d9deeb8><div class="footer-left-wrap" data-v-3d9deeb8><ul class="contact" data-v-3d9deeb8></ul></div> <div class="footer-right-wrap" data-v-3d9deeb8><ul class="copyright" data-v-3d9deeb8></ul></div></footer></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.c4cd884f.js" defer></script><script src="/assets/js/23.d4940eec.js" defer></script><script src="/assets/js/5.5d32c9ea.js" defer></script><script src="/assets/js/24.e000ab2c.js" defer></script>
  </body>
</html>
