<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>React Virtual DOM 与 diff 算法 | 既然选择了远方，便只顾风雨兼程</title>
    <meta name="generator" content="VuePress 1.9.9">
    <link ref="icon" href="./public/favicon.icon">
    <meta name="description" content=" React 最大的亮点应该就是将 virtual dom 和高效的 diff 算法结合。

一、 React 对 diff 算法的设想

传统的 diff 算法通过循环递归对接点进行一次对比，时间复杂度为` O(n^3) ...">
    
    <link rel="preload" href="/assets/css/0.styles.730f6d4f.css" as="style"><link rel="preload" href="/assets/js/app.c4cd884f.js" as="script"><link rel="preload" href="/assets/js/23.d4940eec.js" as="script"><link rel="preload" href="/assets/js/5.5d32c9ea.js" as="script"><link rel="preload" href="/assets/js/14.37d92c2e.js" as="script"><link rel="prefetch" href="/assets/js/10.a13898e2.js"><link rel="prefetch" href="/assets/js/11.ea480a48.js"><link rel="prefetch" href="/assets/js/12.0623054f.js"><link rel="prefetch" href="/assets/js/13.ef25626c.js"><link rel="prefetch" href="/assets/js/15.186b7794.js"><link rel="prefetch" href="/assets/js/16.3a23dbe1.js"><link rel="prefetch" href="/assets/js/17.cf1e4c9d.js"><link rel="prefetch" href="/assets/js/18.733102b1.js"><link rel="prefetch" href="/assets/js/19.eb455b58.js"><link rel="prefetch" href="/assets/js/20.e1adbccc.js"><link rel="prefetch" href="/assets/js/21.70504574.js"><link rel="prefetch" href="/assets/js/22.a40e7218.js"><link rel="prefetch" href="/assets/js/24.e000ab2c.js"><link rel="prefetch" href="/assets/js/25.2fe1472c.js"><link rel="prefetch" href="/assets/js/26.84502e94.js"><link rel="prefetch" href="/assets/js/27.c5d352fe.js"><link rel="prefetch" href="/assets/js/28.8e4ee861.js"><link rel="prefetch" href="/assets/js/29.fb15a9ed.js"><link rel="prefetch" href="/assets/js/3.2bd813b0.js"><link rel="prefetch" href="/assets/js/30.baf8f290.js"><link rel="prefetch" href="/assets/js/31.369fdd21.js"><link rel="prefetch" href="/assets/js/32.c0176c82.js"><link rel="prefetch" href="/assets/js/33.b3200294.js"><link rel="prefetch" href="/assets/js/34.08880f00.js"><link rel="prefetch" href="/assets/js/35.133a227c.js"><link rel="prefetch" href="/assets/js/36.293f2b2b.js"><link rel="prefetch" href="/assets/js/37.f92a5aa5.js"><link rel="prefetch" href="/assets/js/38.11242c63.js"><link rel="prefetch" href="/assets/js/39.1540f3d9.js"><link rel="prefetch" href="/assets/js/4.dde594c9.js"><link rel="prefetch" href="/assets/js/40.bc77545d.js"><link rel="prefetch" href="/assets/js/41.fe6b364e.js"><link rel="prefetch" href="/assets/js/42.6b17d3ae.js"><link rel="prefetch" href="/assets/js/43.d988bf22.js"><link rel="prefetch" href="/assets/js/44.9b709226.js"><link rel="prefetch" href="/assets/js/45.0797ebde.js"><link rel="prefetch" href="/assets/js/46.d41406d1.js"><link rel="prefetch" href="/assets/js/47.26d992a5.js"><link rel="prefetch" href="/assets/js/48.edf0660d.js"><link rel="prefetch" href="/assets/js/49.e1bd4b64.js"><link rel="prefetch" href="/assets/js/50.17997f4a.js"><link rel="prefetch" href="/assets/js/51.0731d59f.js"><link rel="prefetch" href="/assets/js/52.718863ae.js"><link rel="prefetch" href="/assets/js/53.4d2f7088.js"><link rel="prefetch" href="/assets/js/54.91ac93f6.js"><link rel="prefetch" href="/assets/js/55.3216e5c5.js"><link rel="prefetch" href="/assets/js/56.a2736731.js"><link rel="prefetch" href="/assets/js/57.93476b89.js"><link rel="prefetch" href="/assets/js/58.9984e9d6.js"><link rel="prefetch" href="/assets/js/59.27eeb159.js"><link rel="prefetch" href="/assets/js/6.e9162c19.js"><link rel="prefetch" href="/assets/js/60.83f3f7cd.js"><link rel="prefetch" href="/assets/js/61.322f6435.js"><link rel="prefetch" href="/assets/js/62.af66f292.js"><link rel="prefetch" href="/assets/js/63.777e9119.js"><link rel="prefetch" href="/assets/js/64.05118592.js"><link rel="prefetch" href="/assets/js/65.9ba14b43.js"><link rel="prefetch" href="/assets/js/66.62408b82.js"><link rel="prefetch" href="/assets/js/67.fa72ffa1.js"><link rel="prefetch" href="/assets/js/68.c16dfb41.js"><link rel="prefetch" href="/assets/js/7.f41c39e4.js"><link rel="prefetch" href="/assets/js/8.cd0ad175.js"><link rel="prefetch" href="/assets/js/9.f1977faa.js"><link rel="prefetch" href="/assets/js/vuejs-paginate.8fa4990d.js">
    <link rel="stylesheet" href="/assets/css/0.styles.730f6d4f.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div id="vuepress-theme-blog__global-layout"><section id="header-wrapper"><header id="header"><div class="header-wrapper"><div class="title"><a href="/" class="nav-link home-link">既然选择了远方，便只顾风雨兼程 </a></div> <div class="header-right-wrap"><ul class="nav"><li class="nav-item"><a href="/" class="nav-link">Blog</a></li><li class="nav-item"><a href="/tag/" class="nav-link">Tags</a></li><li class="nav-item"><a href="/2019/10/20/base-list/" class="nav-link">学习资源</a></li><li class="nav-item"><a href="/handbook/" class="nav-link">前端学习手册</a></li><li class="nav-item"><a href="/tag/Reading%20Notes/" class="nav-link">读书笔记</a></li></ul> <div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></div></header></section> <div id="mobile-header"><div class="mobile-header-bar"><div class="mobile-header-title"><a href="/" class="nav-link mobile-home-link">既然选择了远方，便只顾风雨兼程 </a> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg></div> <div class="mobile-menu-wrapper"><hr class="menu-divider"> <ul class="mobile-nav"><li class="mobile-nav-item"><a href="/" class="nav-link">Blog</a></li><li class="mobile-nav-item"><a href="/tag/" class="nav-link">Tags</a></li><li class="mobile-nav-item"><a href="/2019/10/20/base-list/" class="nav-link">学习资源</a></li><li class="mobile-nav-item"><a href="/handbook/" class="nav-link">前端学习手册</a></li><li class="mobile-nav-item"><a href="/tag/Reading%20Notes/" class="nav-link">读书笔记</a></li> <li class="mobile-nav-item"><!----></li></ul></div></div></div> <div class="content-wrapper"><div id="vuepress-theme-blog__post-layout"><article itemscope="itemscope" itemtype="https://schema.org/BlogPosting" class="vuepress-blog-theme-content"><header><h1 itemprop="name headline" class="post-title">
        React Virtual DOM 与 diff 算法
      </h1> <div class="post-meta"><div itemprop="publisher author" itemtype="http://schema.org/Person" itemscope="itemscope" class="post-meta-author"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-navigation"><polygon points="3 11 22 2 13 21 11 13 3 11"></polygon></svg> <span itemprop="name">lili</span> <span itemprop="address">   in shenzhen</span></div> <div class="post-meta-date"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-clock"><circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline></svg> <time pubdate itemprop="datePublished" datetime="2018-10-18T00:00:00.000Z">
      Thu Oct 18 2018
    </time></div> <ul itemprop="keywords" class="post-meta-tags"><li class="post-tag" data-v-42ccfcd5><a href="/tag/JavaScript" data-v-42ccfcd5><span data-v-42ccfcd5>JavaScript</span></a></li><li class="post-tag" data-v-42ccfcd5><a href="/tag/React" data-v-42ccfcd5><span data-v-42ccfcd5>React</span></a></li></ul></div></header> <div itemprop="articleBody" class="content__default"><p><code>React</code>最大的亮点应该就是将<code>virtual dom</code>和高效的<code>diff</code>算法结合。</p> <h2 id="一、react对diff算法的设想"><a href="#一、react对diff算法的设想" class="header-anchor">#</a> 一、<code>React</code>对<code>diff</code>算法的设想</h2> <p><a href="https://grfia.dlsi.ua.es/ml/algorithms/references/editsurvey_bille.pdf" target="_blank" rel="noopener noreferrer">传统的<code>diff</code>算法<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>通过循环递归对接点进行一次对比，时间复杂度为<code>O(n^3)</code>，其中<code>n</code>指<code>Dom</code>树中元素的个数。这意味着如果要展示<code>1000</code>个节点，就要依次执行上十亿次的比较。这种指数型的性能消耗对于前端渲染场景来说代价太高了！现今的<code>CPU</code> 每秒钟能执行大约<code>30</code>亿条指令，即便是最高效的实现，也不可能在一秒内计算出差异情况。</p> <p><code>React</code>为了提高<code>diff</code>算法效率，基于下面的假设，实现了一个时间复杂度为<code>O(n)</code>的<code>diff</code>算法：</p> <ol><li>两个不同类型的元素将产生不同的树。</li> <li>开发者可以通过指定<code>key</code>属性值，示意哪些子元素可能是稳定的。</li></ol> <p>实践中，上述假设适用于大部分应用场景。</p> <h3 id="_1-1-假设一"><a href="#_1-1-假设一" class="header-anchor">#</a> <code>1.1</code> 假设一</h3> <p>当对比两棵树时，<code>React</code>首先比较两个根节点。根节点的<code>type</code>不同，其行为也不同。</p> <h4 id="_1-1-1-不同类型的元素"><a href="#_1-1-1-不同类型的元素" class="header-anchor">#</a> <code>1.1.1</code> 不同类型的元素</h4> <p>每当根元素有不同类型，<code>React</code>将卸载旧树并重新构建新树。</p> <p>当树被卸载，旧的<code>DOM</code>节点将被销毁。组件实例会调用<code>componentWillUnmount()</code>。当构建一棵新树，新的<code>DOM</code>节点被插入到<code>DOM</code>中。组件实例将依次调用<code>componentWillMount()</code> 和<code>componentDidMount()</code>。任何与旧树有关的状态都将丢弃。</p> <p>例如，以下节点对比之后：</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Counter</span> <span class="token punctuation">/&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Counter</span> <span class="token punctuation">/&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>这将会销毁旧的<code>Counter</code>并重装新的<code>Counter</code>。</p> <h4 id="_1-1-2-相同类型的dom元素"><a href="#_1-1-2-相同类型的dom元素" class="header-anchor">#</a> <code>1.1.2</code> 相同类型的<code>DOM</code>元素</h4> <ul><li>对于类型相同的<code>React DOM</code> 元素，<code>React</code>会对比两者的属性是否相同，只更新不同的属性</li> <li>当处理完这个<code>DOM</code>节点，<code>React</code>就会递归处理子节点。</li></ul> <div class="language-html extra-class"><pre class="language-html"><code><span class="token comment">&lt;!-- 旧 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">className</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>before<span class="token punctuation">&quot;</span></span> <span class="token attr-name">title</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>stuff<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
<span class="token comment">&lt;!-- 新 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">className</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>after<span class="token punctuation">&quot;</span></span> <span class="token attr-name">title</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>stuff<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
<span class="token comment">&lt;!-- 只更新：className 属性 --&gt;</span>

<span class="token comment">&lt;!-- 旧 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token special-attr"><span class="token attr-name">style</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token value css language-css"><span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token property">color</span><span class="token punctuation">:</span></span></span></span> <span class="token attr-name">'red',</span> <span class="token attr-name"><span class="token namespace">fontWeight:</span></span> <span class="token attr-name">'bold'}}</span> <span class="token punctuation">/&gt;</span></span>
<span class="token comment">&lt;!-- 新 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token special-attr"><span class="token attr-name">style</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token value css language-css"><span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token property">color</span><span class="token punctuation">:</span></span></span></span> <span class="token attr-name">'green',</span> <span class="token attr-name"><span class="token namespace">fontWeight:</span></span> <span class="token attr-name">'bold'}}</span> <span class="token punctuation">/&gt;</span></span>
<span class="token comment">&lt;!-- 只更新：color属性 --&gt;</span>
</code></pre></div><h4 id="_1-1-3-相同类型的组件元素"><a href="#_1-1-3-相同类型的组件元素" class="header-anchor">#</a> <code>1.1.3</code> 相同类型的组件元素</h4> <p>当组件更新时，实例仍保持一致，以让状态能够在渲染之间保留。<code>React</code>通过更新底层组件实例的<code>props</code>来产生新元素，并在底层实例上依次调用<code>componentWillReceiveProps()</code>和<code>componentWillUpdate()</code>方法。</p> <p>接下来，<code>render()</code>方法被调用，同时对比算法会递归处理之前的结果和新的结果。</p> <h4 id="_1-1-4-递归子节点"><a href="#_1-1-4-递归子节点" class="header-anchor">#</a> <code>1.1.4</code> 递归子节点</h4> <p>默认时。当递归<code>DOM</code>节点的子节点，<code>React</code>仅在同一时间点递归两个子节点列表，并在有不同时产生一个变更。</p> <p>例如，当在子节点末尾增加一个元素，两棵树的转换效果很好：</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>first<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>second<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>first<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>second<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>third<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>若在开始位置插入元素则会使得性能很棘手。例如，两棵树的转换效果则比较糟糕：</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>Duke<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>Villanova<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>Connecticut<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>Duke<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>Villanova<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p><code>React</code>会调整每个子节点，不会意识到可以完整保留<code>&lt;li&gt;Duke&lt;/li&gt;</code>和<code>&lt;li&gt;Villanova&lt;/li&gt;</code>子树。低效成了一个问题。</p> <h3 id="_1-2-假设二-key"><a href="#_1-2-假设二-key" class="header-anchor">#</a> <code>1.2</code> 假设二：<code>Key</code></h3> <p>为解决该问题，<code>React</code>支持了一个<code>key</code>属性。当子节点有<code>key</code>时，<code>React</code>使用<code>key</code>来匹配原本树的子节点和新树的子节点。</p> <h2 id="二、diff解析"><a href="#二、diff解析" class="header-anchor">#</a> 二、<code>diff</code>解析</h2> <p>基于以上假设，<code>React</code>分别对<code>tree diff</code>、<code>component diff</code>以及<code>element diff</code>进行算法优化</p> <h3 id="_2-1-tree-diff"><a href="#_2-1-tree-diff" class="header-anchor">#</a> <code>2.1</code> <code>tree diff</code></h3> <p><code>React</code>对不同类型的节点的处理逻辑我们很容易得到推论，那就是<code>React</code>的<code>DOM Diff</code>算法实际上只会对树进行逐层比较，两棵树只会对同一层次的节点进行比较，如下所述：</p> <p><img src="/assets/img/01.1f522dc1.png" alt="image from dependency"></p> <p><code>React</code>只会对相同颜色方框内的<code>DOM</code>节点进行比较，即同一个父节点下的所有子节点。当发现节点已经不存在，则该节点及其子节点会被完全删除掉，不会用于进一步的比较。这样只需要对树进行一次遍历，便能完成整个<code>DOM</code>树的比较。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function-variable function">updateChildren</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">nextNestedChildrenElements<span class="token punctuation">,</span> transaction<span class="token punctuation">,</span> context</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  updateDepth<span class="token operator">++</span><span class="token punctuation">;</span>
  <span class="token keyword">var</span> errorThrown <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
  <span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">_updateChildren</span><span class="token punctuation">(</span>nextNestedChildrenElements<span class="token punctuation">,</span> transaction<span class="token punctuation">,</span> context<span class="token punctuation">)</span><span class="token punctuation">;</span>
    errorThrown <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
    updateDepth<span class="token operator">--</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>updateDepth<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>errorThrown<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">clearQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token function">processQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>如果出现了<code>DOM</code>节点跨层级的移动操作，如下图，<code>React diff</code>会有怎样的表现呢</p> <p><img src="/assets/img/02.e1a32e64.png" alt="image from dependency"></p> <p>如图，<code>A</code>节点（包括其子节点）整个被移动到<code>D</code>节点下，由于<code>React</code> 只会简单的考虑同层级节点的位置变换，而对于不同层级的节点，只有创建和删除操作。当根节点发现子节点中<code>A</code> 消失了，就会直接销毁<code>A</code>；当<code>D</code>发现多了一个子节点<code>A</code>，则会创建新的<code>A</code>（包括子节点）作为其子节点。此时，<code>React diff</code>的执行情况：<code>create A -&gt; create B -&gt; create C -&gt; delete A</code>。</p> <p>由此可发现，当出现节点跨层级移动时，并不会出现想象中的移动操作，而是以<code>A</code> 为根节点的树被整个重新创建，这是一种影响<code>React</code> 性能的操作，因此<code>React</code>官方建议不要进行<code>DOM</code> 节点跨层级的操作。</p> <p>注意：在开发组件时，保持稳定的<code>DOM</code> 结构会有助于性能的提升。例如，可以通过<code>CSS</code> 隐藏或显示节点，而不是真的移除或添加<code>DOM</code>节点。</p> <h3 id="_2-2-component-diff"><a href="#_2-2-component-diff" class="header-anchor">#</a> <code>2.2</code> <code>component diff</code></h3> <p><code>React</code>是基于组件构建应用的，对于组件间的比较所采取的策略也是简洁高效。</p> <ul><li><p>如果是同一类型的组件，按照原策略继续比较<code>virtual DOM tree</code>。</p></li> <li><p>如果不是，则将该组件判断为<code>dirty component</code>，从而替换整个组件下的所有子节点。</p></li> <li><p>对于同一类型的组件，有可能其<code>Virtual DOM</code> 没有任何变化，如果能够确切的知道这点那可以节省大量的<code>diff</code>运算时间，因此<code>React</code>允许用户通过<code>shouldComponentUpdate()</code>来判断该组件是否需要进行<code>diff</code>。</p></li></ul> <p>如下图，当<code>component D</code>改变为<code>component G</code> 时，即使这两个<code>component</code>结构相似，一旦<code>React</code>判断 <code>D</code>和<code>G</code>是不同类型的组件，就不会比较二者的结构，而是直接删除<code>component D</code>，重新创建<code>component G</code> 以及其子节点。虽然当两个<code>component</code> 是不同类型但结构相似时，<code>React diff</code>会影响性能，但正如<code>React</code>官方博客所言：不同类型的 <code>component</code>是很少存在相似<code>DOM tree</code> 的机会，因此这种极端因素很难在实现开发过程中造成重大影响的。</p> <p><img src="/assets/img/03.0c5dd8d7.jpg" alt="image from dependency"></p> <h3 id="_2-3-element-diff"><a href="#_2-3-element-diff" class="header-anchor">#</a> <code>2.3</code> <code>element diff</code></h3> <p>当节点处于同一层级时，<code>React diff</code> 提供了三种节点操作，分别为：<code>INSERT_MARKUP</code>（插入）、<code>MOVE_EXISTING</code>（移动）和<code>REMOVE_NODE</code>（删除）。</p> <ul><li><code>INSERT_MARKUP</code>：新的<code>component</code>类型不在老集合里， 即是全新的节点，需要对新节点执行插入操作。</li> <li><code>MOVE_EXISTING</code>：在老集合有新<code>component</code>类型，且 <code>element</code>是可更新的类型，<code>generateComponentChildren</code>已调用<code>receiveComponent</code>，这种情况下 <code>prevChild=nextChild</code>，就需要做移动操作，可以复用以前的 <code>DOM</code>节点。</li> <li><code>REMOVE_NODE</code>：老<code>component</code> 类型，在新集合里也有，但对应的<code>element</code> 不同则不能直接复用和更新，需要执行删除操作，或者老<code>component</code>不在新集合里的，也需要执行删除操作。</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">enqueueInsertMarkup</span><span class="token punctuation">(</span><span class="token parameter">parentInst<span class="token punctuation">,</span> markup<span class="token punctuation">,</span> toIndex</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  updateQueue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    <span class="token literal-property property">parentInst</span><span class="token operator">:</span> parentInst<span class="token punctuation">,</span>
    <span class="token literal-property property">parentNode</span><span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
    <span class="token literal-property property">type</span><span class="token operator">:</span> ReactMultiChildUpdateTypes<span class="token punctuation">.</span><span class="token constant">INSERT_MARKUP</span><span class="token punctuation">,</span>
    <span class="token literal-property property">markupIndex</span><span class="token operator">:</span> markupQueue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>markup<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span>
    <span class="token literal-property property">content</span><span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
    <span class="token literal-property property">fromIndex</span><span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
    <span class="token literal-property property">toIndex</span><span class="token operator">:</span> toIndex<span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">enqueueMove</span><span class="token punctuation">(</span><span class="token parameter">parentInst<span class="token punctuation">,</span> fromIndex<span class="token punctuation">,</span> toIndex</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  updateQueue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    <span class="token literal-property property">parentInst</span><span class="token operator">:</span> parentInst<span class="token punctuation">,</span>
    <span class="token literal-property property">parentNode</span><span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
    <span class="token literal-property property">type</span><span class="token operator">:</span> ReactMultiChildUpdateTypes<span class="token punctuation">.</span><span class="token constant">MOVE_EXISTING</span><span class="token punctuation">,</span>
    <span class="token literal-property property">markupIndex</span><span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
    <span class="token literal-property property">content</span><span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
    <span class="token literal-property property">fromIndex</span><span class="token operator">:</span> fromIndex<span class="token punctuation">,</span>
    <span class="token literal-property property">toIndex</span><span class="token operator">:</span> toIndex<span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">enqueueRemove</span><span class="token punctuation">(</span><span class="token parameter">parentInst<span class="token punctuation">,</span> fromIndex</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  updateQueue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    <span class="token literal-property property">parentInst</span><span class="token operator">:</span> parentInst<span class="token punctuation">,</span>
    <span class="token literal-property property">parentNode</span><span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
    <span class="token literal-property property">type</span><span class="token operator">:</span> ReactMultiChildUpdateTypes<span class="token punctuation">.</span><span class="token constant">REMOVE_NODE</span><span class="token punctuation">,</span>
    <span class="token literal-property property">markupIndex</span><span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
    <span class="token literal-property property">content</span><span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
    <span class="token literal-property property">fromIndex</span><span class="token operator">:</span> fromIndex<span class="token punctuation">,</span>
    <span class="token literal-property property">toIndex</span><span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>如下图，老集合中包含节点：<code>A</code>、<code>B</code>、<code>C</code>、<code>D</code>，更新后的新集合中包含节点：<code>B</code>、<code>A</code>、<code>D</code>、<code>C</code>，此时新老集合进行<code>diff</code>差异化对比，发现<code>B != A</code>，则创建并插入<code>B</code>至新集合，删除老集合<code>A</code>；以此类推，创建并插入<code>A</code>、<code>D</code>和<code>C</code>，删除<code>B</code>、<code>C</code>和<code>D</code>。</p> <p><img src="/assets/img/04.52d8a284.jpg" alt="image from dependency"></p> <p><code>React</code>发现这类操作繁琐冗余，因为这些都是相同的节点，但由于位置发生变化，导致需要进行繁杂低效的删除、创建操作，其实只要对这些节点进行位置移动即可。</p> <p>针对这一现象，<code>React</code> 提出优化策略：允许开发者对同一层级的同组子节点，添加唯一<code>key</code>进行区分，虽然只是小小的改动，性能上却发生了翻天覆地的变化！</p> <p>新老集合所包含的节点，如下图所示，新老集合进行<code>diff</code> 差异化对比，通过<code>key</code> 发现新老集合中的节点都是相同的节点，因此无需进行节点删除和创建，只需要将老集合中节点的位置进行移动，更新为新集合中节点的位置，此时<code>React</code>给出的<code>diff</code> 结果为：<code>B</code>、<code>D</code>不做任何操作，<code>A</code>、<code>C</code>进行移动操作，即可。</p> <p><img src="/assets/img/05.b42472a3.jpg" alt="image from dependency"></p> <p>那么，如此高效的<code>diff</code> 到底是如何运作的呢？让我们通过源码进行详细分析。</p> <p>首先对新集合的节点进行循环遍历，<code>for (name in nextChildren)</code>，通过唯一<code>key</code> 可以判断新老集合中是否存在相同的节点，<code>if (prevChild === nextChild)</code>，如果存在相同节点，则进行移动操作，但在移动前需要将当前节点在老集合中的位置与<code>lastIndex</code>进行比较，<code>if (child._mountIndex &lt; lastIndex)</code>，则进行节点移动操作，否则不执行该操作。这是一种顺序优化手段，<code>lastIndex</code> 一直在更新，表示访问过的节点在老集合中最右的位置（即最大的位置），如果新集合中当前访问的节点比<code>lastIndex</code> 大，说明当前访问节点在老集合中就比上一个节点位置靠后，则该节点不会影响其他节点的位置，因此不用添加到差异队列中，即不执行移动操作，只有当访问的节点比<code>lastIndex</code> 小时，才需要进行移动操作，流程如下：</p> <p><img src="/assets/img/06.5b473d17.png" alt="image from dependency"></p> <p>以上图为例，可以更为清晰直观的描述<code>diff</code> 的差异对比过程：</p> <ul><li><p>从新集合中取得<code>B</code>，判断老集合中存在相同节点 <code>B</code>，通过对比节点位置判断是否进行移动操作，<code>B</code> 在老集合中的位置<code>B._mountIndex = 1</code>，此时<code>lastIndex = 0</code>，不满足<code>child._mountIndex &lt; lastIndex</code>的条件，因此不对<code>B</code>进行移动操作；更新<code>lastIndex = Math.max(prevChild._mountIndex, lastIndex)</code>，其中 <code>prevChild._mountIndex</code>表示<code>B</code>在老集合中的位置，则 <code>lastIndex ＝ 1</code>，并将<code>B</code> 的位置更新为新集合中的位置<code>prevChild._mountIndex = nextIndex</code>，此时新集合中 <code>B._mountIndex = 0</code>，<code>nextIndex++</code> 进入下一个节点的判断。</p></li> <li><p>从新集合中取得<code>A</code>，判断老集合中存在相同节点 <code>A</code>，通过对比节点位置判断是否进行移动操作，<code>A</code> 在老集合中的位置<code>A._mountIndex = 0</code>，此时<code>lastIndex = 1</code>，满足<code>child._mountIndex &lt; lastIndex</code>的条件，因此对<code>A</code>进行移动操作<code>enqueueMove(this, child._mountIndex, toIndex)</code>，其中<code>toIndex</code>其实就是 <code>nextIndex</code>，表示<code>A</code>需要移动到的位置；更新 <code>lastIndex = Math.max(prevChild._mountIndex, lastIndex)</code>，则<code>lastIndex ＝ 1</code>，并将<code>A</code> 的位置更新为新集合中的位置<code>prevChild._mountIndex = nextIndex</code>，此时新集合中 <code>A._mountIndex = 1</code>，<code>nextIndex++</code>进入下一个节点的判断。</p></li> <li><p>从新集合中取得<code>D</code>，判断老集合中存在相同节点 <code>D</code>，通过对比节点位置判断是否进行移动操作，<code>D</code> 在老集合中的位置<code>D._mountIndex = 3</code>，此时<code>lastIndex = 1</code>，不满足<code>child._mountIndex &lt; lastIndex</code>的条件，因此不对<code>D</code>进行移动操作；更新<code>lastIndex = Math.max(prevChild._mountIndex, lastIndex)</code>，则 <code>lastIndex ＝ 3</code>，并将<code>D</code>的位置更新为新集合中的位置 <code>prevChild._mountIndex = nextIndex</code>，此时新集合中<code>D._mountIndex = 2</code>，<code>nextIndex++</code> 进入下一个节点的判断。</p></li> <li><p>从新集合中取得<code>C</code>，判断老集合中存在相同节点<code>C</code>，通过对比节点位置判断是否进行移动操作，<code>C</code> 在老集合中的位置<code>C._mountIndex = 2</code>，此时<code>lastIndex = 3</code>，满足<code>child._mountIndex &lt; lastIndex</code> 的条件，因此对<code>C</code>进行移动操作<code>enqueueMove(this, child._mountIndex, toIndex)</code>；更新<code>lastIndex = Math.max(prevChild._mountIndex, lastIndex)</code>，则 <code>lastIndex ＝ 3</code>，并将<code>C</code>的位置更新为新集合中的位置 <code>prevChild._mountIndex = nextIndex</code>，此时新集合中 <code>C._mountIndex = 3</code>，<code>nextIndex++</code> 进入下一个节点的判断，由于 C 已经是最后一个节点，因此 <code>diff</code>到此完成。</p></li></ul> <p>以上主要分析新老集合中存在相同节点但位置不同时，对节点进行位置移动的情况，如果新集合中有新加入的节点且老集合存在需要删除的节点，那么<code>React diff</code> 又是如何对比运作的呢？</p> <p>以下图为例：</p> <p><img src="/assets/img/07.a9b0be29.jpg" alt="image from dependency"></p> <ul><li><p>从新集合中取得<code>B</code>，判断老集合中存在相同节点<code>B</code>，由于<code>B</code>在老集合中的位置<code>B._mountIndex = 1</code>，此时<code>lastIndex = 0</code>，因此不对<code>B</code>进行移动操作；更新<code>lastIndex ＝ 1</code>，并将<code>B</code>的位置更新为新集合中的位置<code>B._mountIndex = 0</code>，<code>nextIndex++</code>进入下一个节点的判断。</p></li> <li><p>从新集合中取得<code>E</code>，判断老集合中不存在相同节点 <code>E</code>，则创建新节点<code>E</code>；更新<code>lastIndex ＝ 1</code>，并将<code>E</code>的位置更新为新集合中的位置，<code>nextIndex++</code>进入下一个节点的判断。</p></li> <li><p>从新集合中取得<code>C</code>，判断老集合中存在相同节点<code>C</code>，由于<code>C</code>在老集合中的位置<code>C._mountIndex = 2</code>，<code>lastIndex = 1</code>，此时<code>C._mountIndex &gt; lastIndex</code>，因此不对<code>C</code>进行移动操作；更新<code>lastIndex ＝ 2</code>，并将<code>C</code>的位置更新为新集合中的位置，<code>nextIndex++</code>进入下一个节点的判断。</p></li> <li><p>从新集合中取得<code>A</code>，判断老集合中存在相同节点<code>A</code>，由于<code>A</code>在老集合中的位置<code>A._mountIndex = 0</code>，<code>lastIndex = 2</code>，此时<code>A._mountIndex &lt; lastIndex</code>，因此对<code>A</code>进行移动操作；更新<code>lastIndex ＝ 2</code>，并将<code>A</code>的位置更新为新集合中的位置，<code>nextIndex++</code>进入下一个节点的判断。</p></li> <li><p>当完成新集合中所有节点<code>diff</code> 时，最后还需要对老集合进行循环遍历，判断是否存在新集合中没有但老集合中仍存在的节点，发现存在这样的节点<code>D</code>，因此删除节点<code>D</code>，到此<code>diff</code>全部完成。</p></li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function-variable function">_updateChildren</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">nextNestedChildrenElements<span class="token punctuation">,</span> transaction<span class="token punctuation">,</span> context</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> prevChildren <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_renderedChildren<span class="token punctuation">;</span>
  <span class="token keyword">var</span> nextChildren <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">_reconcilerUpdateChildren</span><span class="token punctuation">(</span>
    prevChildren<span class="token punctuation">,</span> nextNestedChildrenElements<span class="token punctuation">,</span> transaction<span class="token punctuation">,</span> context
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>nextChildren <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>prevChildren<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">var</span> name<span class="token punctuation">;</span>
  <span class="token keyword">var</span> lastIndex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">var</span> nextIndex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span>name <span class="token keyword">in</span> nextChildren<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>nextChildren<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">continue</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">var</span> prevChild <span class="token operator">=</span> prevChildren <span class="token operator">&amp;&amp;</span> prevChildren<span class="token punctuation">[</span>name<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> nextChild <span class="token operator">=</span> nextChildren<span class="token punctuation">[</span>name<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>prevChild <span class="token operator">===</span> nextChild<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 移动节点</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">moveChild</span><span class="token punctuation">(</span>prevChild<span class="token punctuation">,</span> nextIndex<span class="token punctuation">,</span> lastIndex<span class="token punctuation">)</span><span class="token punctuation">;</span>
      lastIndex <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>prevChild<span class="token punctuation">.</span>_mountIndex<span class="token punctuation">,</span> lastIndex<span class="token punctuation">)</span><span class="token punctuation">;</span>
      prevChild<span class="token punctuation">.</span>_mountIndex <span class="token operator">=</span> nextIndex<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>prevChild<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        lastIndex <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>prevChild<span class="token punctuation">.</span>_mountIndex<span class="token punctuation">,</span> lastIndex<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 删除节点</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">_unmountChild</span><span class="token punctuation">(</span>prevChild<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token comment">// 初始化并创建节点</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">_mountChildAtIndex</span><span class="token punctuation">(</span>
        nextChild<span class="token punctuation">,</span> nextIndex<span class="token punctuation">,</span> transaction<span class="token punctuation">,</span> context
      <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    nextIndex<span class="token operator">++</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span>name <span class="token keyword">in</span> prevChildren<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>prevChildren<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
        <span class="token operator">!</span><span class="token punctuation">(</span>nextChildren <span class="token operator">&amp;&amp;</span> nextChildren<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">_unmountChild</span><span class="token punctuation">(</span>prevChildren<span class="token punctuation">[</span>name<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>_renderedChildren <span class="token operator">=</span> nextChildren<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token comment">// 移动节点</span>
<span class="token function-variable function">moveChild</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">child<span class="token punctuation">,</span> toIndex<span class="token punctuation">,</span> lastIndex</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>child<span class="token punctuation">.</span>_mountIndex <span class="token operator">&lt;</span> lastIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">prepareToManageChildren</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">enqueueMove</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> child<span class="token punctuation">.</span>_mountIndex<span class="token punctuation">,</span> toIndex<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token comment">// 创建节点</span>
<span class="token function-variable function">createChild</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">child<span class="token punctuation">,</span> mountImage</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">prepareToManageChildren</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">enqueueInsertMarkup</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> mountImage<span class="token punctuation">,</span> child<span class="token punctuation">.</span>_mountIndex<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token comment">// 删除节点</span>
<span class="token function-variable function">removeChild</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">child</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">prepareToManageChildren</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">enqueueRemove</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> child<span class="token punctuation">.</span>_mountIndex<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span>

<span class="token function-variable function">_unmountChild</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">child</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>child<span class="token punctuation">)</span><span class="token punctuation">;</span>
  child<span class="token punctuation">.</span>_mountIndex <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span>

<span class="token function-variable function">_mountChildAtIndex</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span>
  <span class="token parameter">child<span class="token punctuation">,</span>
  index<span class="token punctuation">,</span>
  transaction<span class="token punctuation">,</span>
  context</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> mountImage <span class="token operator">=</span> ReactReconciler<span class="token punctuation">.</span><span class="token function">mountComponent</span><span class="token punctuation">(</span>
    child<span class="token punctuation">,</span>
    transaction<span class="token punctuation">,</span>
    <span class="token keyword">this</span><span class="token punctuation">,</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>_nativeContainerInfo<span class="token punctuation">,</span>
    context
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
  child<span class="token punctuation">.</span>_mountIndex <span class="token operator">=</span> index<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">createChild</span><span class="token punctuation">(</span>child<span class="token punctuation">,</span> mountImage<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span>
</code></pre></div><p>当然，<code>React diff</code> 还是存在些许不足与待优化的地方，如下图所示，若新集合的节点更新为：<code>D</code>、<code>A</code>、<code>B</code>、<code>C</code>，与老集合对比只有<code>D</code>节点移动，而<code>A</code>、<code>B</code>、<code>C</code>仍然保持原有的顺序，理论上<code>diff</code>应该只需对<code>D</code> 执行移动操作，然而由于<code>D</code> 在老集合的位置是最大的，导致其他节点的<code>_mountIndex &lt; lastIndex</code>，造成<code>D</code>没有执行移动操作，而是<code>A</code>、<code>B</code>、<code>C</code>全部移动到<code>D</code>节点后面的现象。</p> <p><img src="/assets/img/08.b834d81a.jpg" alt="image from dependency"></p> <p>建议：在开发过程中，尽量减少类似将最后一个节点移动到列表首部的操作，当节点数量过大或更新操作过于频繁时，在一定程度上会影响<code>React</code>的渲染性能。</p> <h2 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h2> <ul><li><code>React</code>通过制定大胆的<code>diff</code>策略，将<code>O(n3)</code> 复杂度的问题转换成<code>O(n)</code>复杂度的问题；</li> <li><code>React</code>通过分层求异的策略，对<code>tree diff</code> 进行算法优化；</li> <li><code>React</code>通过相同类生成相似树形结构，不同类生成不同树形结构的策略，对<code>component diff</code>进行算法优化；</li> <li><code>React</code>通过设置唯一 <code>key</code>的策略，对<code>element diff</code> 进行算法优化；</li> <li>建议，在开发组件时，保持稳定的<code>DOM</code> 结构会有助于性能的提升；</li> <li>建议，在开发过程中，尽量减少类似将最后一个节点移动到列表首部的操作，当节点数量过大或更新操作过于频繁时，在一定程度上会影响<code>React</code>的渲染性能。</li></ul> <h2 id="参考文献"><a href="#参考文献" class="header-anchor">#</a> 参考文献</h2> <p><a href="https://reactjs.org/docs/reconciliation.html" target="_blank" rel="noopener noreferrer"><code>Reconciliation diff</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><a href="https://react.docschina.org/docs/reconciliation.html" target="_blank" rel="noopener noreferrer"><code>diff</code>算法 中文文档<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><a href="https://zhuanlan.zhihu.com/p/20346379" target="_blank" rel="noopener noreferrer"><code>React</code>源码剖析系列 － 不可思议的<code>react diff</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><a href="http://www.infoq.com/cn/articles/react-dom-diff?from=timeline&amp;isappinstalled=0" target="_blank" rel="noopener noreferrer">深入浅出<code>React</code>（四）：虚拟<code>DOM Diff</code>算法解析
<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></div> <footer><!----> <hr> <!----></footer></article> <div class="sticker vuepress-toc"><div class="vuepress-toc-item vuepress-toc-h2 active"><a href="#一、react对diff算法的设想" title="一、 React 对 diff 算法的设想">一、 React 对 diff 算法的设想</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_1-1-假设一" title="1.1  假设一">1.1  假设一</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_1-2-假设二-key" title="1.2  假设二： Key">1.2  假设二： Key</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#二、diff解析" title="二、 diff 解析">二、 diff 解析</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_2-1-tree-diff" title="2.1   tree diff">2.1   tree diff</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_2-2-component-diff" title="2.2   component diff">2.2   component diff</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_2-3-element-diff" title="2.3   element diff">2.3   element diff</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#总结" title="总结">总结</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#参考文献" title="参考文献">参考文献</a></div></div></div></div> <footer class="footer" data-v-3d9deeb8><div class="footer-left-wrap" data-v-3d9deeb8><ul class="contact" data-v-3d9deeb8></ul></div> <div class="footer-right-wrap" data-v-3d9deeb8><ul class="copyright" data-v-3d9deeb8></ul></div></footer></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.c4cd884f.js" defer></script><script src="/assets/js/23.d4940eec.js" defer></script><script src="/assets/js/5.5d32c9ea.js" defer></script><script src="/assets/js/14.37d92c2e.js" defer></script>
  </body>
</html>
